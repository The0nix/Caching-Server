#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/epoll.h>
#include <string.h>
#include "utils.h"

volatile sig_atomic_t Stop = 0;
int MaxEvents = 10000;

void stop(int blank)
{
    Stop = 1;
}

int main(int argc, char **argv) 
{
        read_conf();
        check_args(argc, argv);
        slog("Program started.\n");
        socklen_t addrlen;
        int bufsize = 1024*1024;
        char *buffer = malloc(bufsize); 

        chroot(".");

        int socket_fd = create_and_bind();
        make_non_blocking(socket_fd);

        int epoll_fd = epoll_create1(0);
        struct epoll_event *events = calloc(MaxEvents, sizeof(events));
        
        struct epoll_event event;
        memset(&event, 0, sizeof(event));
        event.data.fd = sock_fd;
        event.events = EPOLLIN;
 
        if (listen(socket_fd, SOMAXCONN) < 0) {    
            perror("listen");    
            close(socket_fd);
            exit(1);    
        }

        if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &event) < 0) {
            perror("epoll_ctl");
            close(socket_fd);
            exit(1);
        }

        signal(SIGINT, stop);
        signal(SIGTERM, stop);

        std::map<int, int> fdpairs;
        std::map<int, short> fd_ready; // 0 - not ready, 1 - read, 2 - write

        while (!Stop) {    
            int number_of_events = epoll_wait(epoll_fd, events, MaxEvents, -1);
            if (number_of_events < 0) {
                perror("epoll_wait");
                close(sock_fd);
                exit(1);
            }
            
            for (int i = 0; i < number_of_events; ++i) {
                const uint32_t emask = pending_events[i].events;
                const bool e_error = emask & EPOLLERR;
                const bool e_hup = emask & EPOLLHUP;
                const bool e_out = emask & EPOLLOUT;
                const bool e_in = emask & EPOLLIN;
                const int fd = pending_events[i].data.fd;                   
                
                if (e_error || e_hup) {
                    if (e_error) {
                        slog("Error with some socket\n");
                    }
                    close(fd);
                    if (fdpairs.count(fd)) {
                        close(fdpairs[fd]);
                        fdpairs.erace(fd);
                    }
                    continue;
                }
                if (fd == socket_fd) {
                    while(1) {
                        struct sockaddr_in in_addr;
                        socklen_t in_addr_size = sizeof(in_addr);
                        int incoming_fd = accept(sock_fd, (sockaddr*)&in_addr, &in_addr_size);
                        if (-1 == incoming_fd) {
                            if (EAGAIN == errno || EWOULDBLOCK == errno) {
                                break;
                            }
                            else {
                                perror("accept");
                                close(sock_fd);
                                exit(1);
                            }
                        }
                        else {
                            make_non_blocking(incoming_fd);
                            event.data.fd = incoming_fd;
                            event.events = EPOLLIN | EPOLLOUT;
                                if (epoll_ctl(ed, EPOLL_CTL_ADD, incoming_fd, &event) < 0) {
                                perror("epoll_ctl");
                                close(sock_fd);
                                exit(1);
                            }
                            printf("The Client is connected...\n");
                        }
                    }
                } else if (e_out) {
                    recv(new_socket, buffer, bufsize, 0);    
                } else if (e_in) {
                    write(new_socket, "HTTP/1.1 200 OK\n", 16);
                    write(new_socket, "Content-length: 46\n", 19);
                    write(new_socket, "Content-Type: text/html\n\n", 25);
                    write(new_socket, "<html><body><H1>Hello world</H1></body></html>",46);
                    printf("%s\n", buffer);        
                }
            }   
        }    
        free(events);
        close(socket_fd);
        printf("Closing...");
        return 0;
}
